;;; Cyclical figurate numbers
;;
;; Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
;; numbers are all figurate (polygonal) numbers and are generated by
;; the following formulae:
;;
;; Triangle	 	P3,n=n(n+1)/2		1, 3,  6, 10, 15, ...
;; Square	 	P4,n=n2			1, 4,  9, 16, 25, ...
;; Pentagonal	 	P5,n=n(3n−1)/2		1, 5, 12, 22, 35, ...
;; Hexagonal	 	P6,n=n(2n−1)		1, 6, 15, 28, 45, ...
;; Heptagonal	 	P7,n=n(5n−3)/2		1, 7, 18, 34, 55, ...
;; Octagonal	 	P8,n=n(3n−2)		1, 8, 21, 40, 65, ...
;; 
;; The ordered set of three 4-digit numbers: 8128, 2882, 8281, has
;; three interesting properties.
;; 
;; The set is cyclic, in that the last two digits of each number is
;; the first two digits of the next number (including the last number
;; with the first).
;; 
;; Each polygonal type: triangle (P3,127=8128), square (P4,91=8281),
;; and pentagonal (P5,44=2882), is represented by a different number
;; in the set.
;; 
;; This is the only set of 4-digit numbers with this property.
;; 
;; Find the sum of the only ordered set of six cyclic 4-digit numbers
;; for which each polygonal type: triangle, square, pentagonal,
;; hexagonal, heptagonal, and octagonal, is represented by a different
;; number in the set.

(in-package #:pe)

(defun triangle (n)
  (/ (* (1+ n)) 2))

(defun square (n)
  (* n n))

(defun pentagon (n)
  (/ (* n (1- (* 2 n)))))

(defun hexagon (n)
  (* n (1- (* 2 n))))

(defun heptagon (n)
  (/ (* n (- (* 5 n) 3)) 2))

(defun octagon (n)
  (* n (- (* 3 n) 2)))

(defun collect (s gen)
  (loop for i = 1 then (1+ i)
	for n = (funcall gen i)
	until (> n 10000)
	when (and (>= n 1000)
		  (> (mod n 100) 10))
	  collect (cons s n)))

(defun build-list ()
  (append (collect 3 #'triangle)
	  (collect 4 #'square)
	  (collect 5 #'pentagon)
	  (collect 6 #'hexagon)
	  (collect 7 #'heptagon)
	  (collect 8 #'octagon)))

(defun has-one-of-type-p (sol n)
  (loop for s in sol
	when (= (car s) (car n))
	  return t
	finally (return nil)))

(defun cyclicp (n1 n2)
  (= (mod (cdr n1) 100) (floor (cdr n2) 100)))

(defun solve (level sol list)
  (cond
    ((and (= 6 (length sol))
	  (cyclicp (sixth sol) (first sol)))
     sol)
    ((>= (length sol) 6)
     nil)
    (t
     (loop with s
	   for c in list
	   unless (has-one-of-type-p sol c)
	     when (cyclicp (car (last sol)) c)
	       do (setf s (solve (1+ level) (append sol (list c)) list))
	   if s return s))))

(defun euler-061 ()
  (loop with list = (build-list)
	for n in list
	for s = (solve 1 (list n) list)
	until s
	finally (return (reduce #'+ s :key (lambda (x) (cdr x))))))
